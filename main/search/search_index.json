{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Welcome to the Docs","text":""},{"location":"index.html#welcome-to-the-docs","title":"Welcome to the Docs","text":"<p>Managing Kubernetes clusters can be complex, requiring careful orchestration of resources, security, and automation. While Kubernetes provides foundational building blocks, achieving secure, scalable, and efficient multi-tenancy often demands advanced expertise and custom solutions.</p> <p>Template Operator is designed to address these challenges by extending Kubernetes with powerful templating and automation capabilities. It enables administrators to define reusable templates for namespaces and resources, automate their distribution, and streamline the provisioning of tenant environments. With Template Operator, you can:</p> <ul> <li>Create and manage reusable templates for Kubernetes manifests, Helm charts, and more.</li> <li>Parameterize templates for flexible, tenant-specific deployments.</li> <li>Automate resource distribution across namespaces using Template Instances and Cluster Template Instances.</li> <li>Synchronize resources such as secrets and ConfigMaps between namespaces.</li> <li>Adopt GitOps workflows with native Kubernetes custom resources.</li> <li>Achieve multi-tenancy without additional management layers.</li> </ul> <p>Template Operator simplifies cluster administration, enhances security, and enables efficient resource utilization, making multi-tenancy accessible and manageable for organizations of all sizes.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Refer to the installation guide for setting up Template Operator.</p>"},{"location":"changelog.html","title":"Changelog","text":""},{"location":"changelog.html#changelog","title":"Changelog","text":""},{"location":"changelog.html#v01x","title":"v0.1.x","text":""},{"location":"changelog.html#v014","title":"v0.1.4","text":"<p>This version acts as a starting version for Template Operator, introducing Multi Tenant Operator's resource provisioning support as a separate product.</p>"},{"location":"eula.html","title":"EULA","text":""},{"location":"eula.html#eula","title":"EULA","text":"<p>Last revision date: 12 December 2022</p> <p>IMPORTANT: THIS SOFTWARE END-USER LICENSE AGREEMENT (\"EULA\") IS A LEGAL AGREEMENT (\"Agreement\") BETWEEN YOU (THE CUSTOMER, EITHER AS AN INDIVIDUAL OR, IF PURCHASED OR OTHERWISE ACQUIRED BY OR FOR AN ENTITY, AS AN ENTITY) AND Stakater AB OR ITS SUBSIDUARY (\"COMPANY\"). READ IT CAREFULLY BEFORE COMPLETING THE INSTALLATION PROCESS AND USING MULTI TENANT OPERATOR (\"SOFTWARE\"). IT PROVIDES A LICENSE TO USE THE SOFTWARE AND CONTAINS WARRANTY INFORMATION AND LIABILITY DISCLAIMERS. BY INSTALLING AND USING THE SOFTWARE, YOU ARE CONFIRMING YOUR ACCEPTANCE OF THE SOFTWARE AND AGREEING TO BECOME BOUND BY THE TERMS OF THIS AGREEMENT.</p> <p>In order to use the Software under this Agreement, you must receive a license key at the time of purchase, in accordance with the scope of use and other terms specified and as set forth in Section 1 of this Agreement.</p>"},{"location":"eula.html#1-license-grant","title":"1. License Grant","text":"<ul> <li> <p>1.1 General Use. This Agreement grants you a non-exclusive, non-transferable, limited license to the use rights for the Software, subject to the terms and conditions in this Agreement. The Software is licensed, not sold.</p> </li> <li> <p>1.2 Electronic Delivery. All Software and license documentation shall be delivered by electronic means unless otherwise specified on the applicable invoice or at the time of purchase. Software shall be deemed delivered when it is made available for download for you by the Company (\"Delivery\").</p> </li> </ul>"},{"location":"eula.html#2-modifications","title":"2. Modifications","text":"<ul> <li> <p>2.1 No Modifications may be created of the original Software. \"Modification\" means:</p> <ul> <li> <p>(a) Any addition to or deletion from the contents of a file included in the original Software</p> </li> <li> <p>(b) Any new file that contains any part of the original Software</p> </li> </ul> </li> </ul>"},{"location":"eula.html#3-restricted-uses","title":"3. Restricted Uses","text":"<ul> <li> <p>3.1 You shall not (and shall not allow any third party to):</p> <ul> <li> <p>(a) reverse engineer the Software or attempt to reconstruct or discover any source code, underlying ideas, algorithms, file formats or programming interfaces of the Software by any means whatsoever (except and only to the extent that applicable law prohibits or restricts reverse engineering restrictions);</p> </li> <li> <p>(b) distribute, sell, sub-license, rent, lease or use the Software for time sharing, hosting, service provider or like purposes, except as expressly permitted under this Agreement;</p> </li> <li> <p>(c) redistribute the Software;</p> </li> <li> <p>(d) remove any product identification, proprietary, copyright or other notices contained in the Software;</p> </li> <li> <p>(e) modify any part of the Software, create a derivative work of any part of the Software (except as permitted in Section 4), or incorporate the Software, except to the extent expressly authorized in writing by the Company;</p> </li> <li> <p>(f) publicly disseminate performance information or analysis (including, without limitation, benchmarks) from any source relating to the Software;</p> </li> <li> <p>(g) utilize any equipment, device, software, or other means designed to circumvent or remove any form of Source URL or copy protection used by the Company in connection with the Software, or use the Software together with any authorization code, Source URL, serial number, or other copy protection device not supplied by the Company;</p> </li> <li> <p>(h) use the Software to develop a product which is competitive with any of the Company's product offerings;</p> </li> <li> <p>(i) use unauthorized Source URLs or license key(s) or distribute or publish Source URLs or license key(s), except as may be expressly permitted by the Company in writing. If your unique license is ever published, the Company reserves the right to terminate your access without notice.</p> </li> </ul> </li> <li> <p>3.2 Under no circumstances may you use the Software as part of a product or service that provides similar functionality to the Software itself.</p> </li> </ul>"},{"location":"eula.html#4-ownership","title":"4. Ownership","text":"<ul> <li>4.1 Notwithstanding anything to the contrary contained herein, except for the limited license rights expressly provided herein, the Company and its suppliers have and will retain all rights, title and interest (including, without limitation, all patent, copyright, trademark, trade secret and other intellectual property rights) in and to the Software and all copies, modifications and derivative works thereof (including any changes which incorporate any of your ideas, feedback or suggestions). You acknowledge that you are obtaining only a limited license right to the Software, and that irrespective of any use of the words \"purchase\", \"sale\" or like terms hereunder no ownership rights are being conveyed to you under this Agreement or otherwise.</li> </ul>"},{"location":"eula.html#5-fees-and-payment","title":"5. Fees and Payment","text":"<ul> <li>5.1 The Software license fees will be due and payable in full as set forth in the applicable invoice or at the time of purchase. You shall be responsible for all taxes, with-holdings, duties and levies arising from the order (excluding taxes based on the net income of the Company).</li> </ul>"},{"location":"eula.html#6-support-maintenance-and-services","title":"6. Support, Maintenance and Services","text":"<ul> <li>6.1 Subject to the terms and conditions of this Agreement, as set forth in your invoice, and as set forth on the Stakater support page, support and maintenance services may be included with the purchase of your license subscription.</li> </ul>"},{"location":"eula.html#7-disclaimer-of-warranties","title":"7. Disclaimer of Warranties","text":"<ul> <li> <p>7.1 The Software is provided \"as is\", with all faults, defects and errors, and without warranty of any kind. The Company does not warrant that the Software will be free of bugs, errors, or other defects, and the Company shall have no liability of any kind for the use of or inability to use the Software, the Software content or any associated service, and you acknowledge that it is not technically practicable for the Company to do so.</p> </li> <li> <p>7.2 To the maximum extent permitted by applicable law, the Company disclaims all warranties, express, implied, arising by law or otherwise, regarding the Software, the Software content and their respective performance or suitability for your intended use, including without limitation any implied warranty of merchantability, fitness for a particular purpose.</p> </li> </ul>"},{"location":"eula.html#8-limitation-of-liability","title":"8. Limitation of Liability","text":"<ul> <li> <p>8.1 In no event will the Company be liable for any direct, indirect, consequential, incidental, special, exemplary, or punitive damages or liabilities whatsoever arising from or relating to the Software, the Software content or this Agreement, whether based on contract, tort (including negligence), strict liability or other theory, even if the Company has been advised of the possibility of such damages.</p> </li> <li> <p>8.2 In no event will the Company's liability exceed the Software license price as indicated in the invoice. The existence of more than one claim will not enlarge or extend this limit.</p> </li> </ul>"},{"location":"eula.html#9-remedies","title":"9. Remedies","text":"<ul> <li> <p>9.1 Your exclusive remedy and the Company's entire liability for breach of this Agreement shall be limited, at the Company's sole and exclusive discretion, to:</p> <ul> <li> <p>(a) replacement of any defective software or documentation; or</p> </li> <li> <p>(b) refund of the license fee paid to the Company</p> </li> </ul> </li> </ul>"},{"location":"eula.html#10-acknowledgements","title":"10. Acknowledgements","text":"<ul> <li> <p>10.1 Consent to the Use of Data. You agree that the Company and its affiliates may collect and use technical information gathered as part of the product support services. The Company may use this information solely to improve products and services and will not disclose this information in a form that personally identifies individuals or organizations.</p> </li> <li> <p>10.2 Government End Users. If the Software and related documentation are supplied to or purchased by or on behalf of a Government, then the Software is deemed to be \"commercial software\" as that term is used in the acquisition regulation system.</p> </li> </ul>"},{"location":"eula.html#11-third-party-software","title":"11. Third Party Software","text":"<ul> <li> <p>11.1 Examples included in Software may provide links to third party libraries or code (collectively \"Third Party Software\") to implement various functions. Third Party Software does not comprise part of the Software. In some cases, access to Third Party Software may be included along with the Software delivery as a convenience for demonstration purposes. Licensee acknowledges:</p> <ul> <li> <p>(1) That some part of Third Party Software may require additional licensing of copyright and patents from the owners of such, and</p> </li> <li> <p>(2) That distribution of any of the Software referencing or including any portion of a Third Party Software may require appropriate licensing from such third parties</p> </li> </ul> </li> </ul>"},{"location":"eula.html#12-miscellaneous","title":"12. Miscellaneous","text":"<ul> <li> <p>12.1 Entire Agreement. This Agreement sets forth our entire agreement with respect to the Software and the subject matter hereof and supersedes all prior and contemporaneous understandings and agreements whether written or oral.</p> </li> <li> <p>12.2 Amendment. The Company reserves the right, in its sole discretion, to amend this Agreement from time. Amendments are managed as described in General Provisions.</p> </li> <li> <p>12.3 Assignment. You may not assign this Agreement or any of its rights under this Agreement without the prior written consent of The Company and any attempted assignment without such consent shall be void.</p> </li> <li> <p>12.4 Export Compliance. You agree to comply with all applicable laws and regulations, including laws, regulations, orders or other restrictions on export, re-export or redistribution of software.</p> </li> <li> <p>12.5 Indemnification. You agree to defend, indemnify, and hold harmless the Company from and against any lawsuits, claims, losses, damages, fines and expenses (including attorneys' fees and costs) arising out of your use of the Software or breach of this Agreement.</p> </li> <li> <p>12.6 Attorneys' Fees and Costs. The prevailing party in any action to enforce this Agreement will be entitled to recover its attorneys' fees and costs in connection with such action.</p> </li> <li> <p>12.7 Severability. If any provision of this Agreement is held by a court of competent jurisdiction to be invalid, illegal, or unenforceable, the remainder of this Agreement will remain in full force and effect.</p> </li> <li> <p>12.8 Waiver. Failure or neglect by either party to enforce at any time any of the provisions of this license Agreement shall not be construed or deemed to be a waiver of that party's rights under this Agreement.</p> </li> <li> <p>12.9 Audit. The Company may, at its expense, appoint its own personnel or an independent third party to audit the numbers of installations of the Software in use by you. Any such audit shall be conducted upon thirty (30) days prior notice, during regular business hours and shall not unreasonably interfere with your business activities.</p> </li> <li> <p>12.10 Headings. The headings of sections and paragraphs of this Agreement are for convenience of reference only and are not intended to restrict, affect or be of any weight in the interpretation or construction of the provisions of such sections or paragraphs.</p> </li> </ul>"},{"location":"eula.html#13-contact-information","title":"13. Contact Information","text":"<ul> <li>13.1 If you have any questions about this EULA, or if you want to contact the Company for any reason, please direct correspondence to <code>sales@stakater.com</code>.</li> </ul>"},{"location":"troubleshooting.html","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting.html#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"about/benefits.html","title":"Benefits of Template Operator","text":""},{"location":"about/benefits.html#benefits-of-template-operator","title":"Benefits of Template Operator","text":"<p>Template Operator allows admins and platform teams to define reusable YAML templates for namespace resources (like Namespaces, RBAC, NetworkPolicies, ResourceQuotas, etc.), which the operator will render and apply when namespaces are created or updated. It also supports copying of secret and configMap from a particular namespace to multiple namespaces selected via labels.</p>"},{"location":"about/benefits.html#1-consistency-across-namespaces","title":"\ud83d\udd39 1. Consistency Across Namespaces","text":"<ul> <li>Templates ensure that every selected namespace gets the same baseline set of resources (e.g., RBAC roles, quotas, limits, labels, monitoring configs).  </li> <li>Reduces human error compared to manually creating namespace resources.  </li> <li>Guarantees security and compliance standards are applied uniformly.</li> </ul>"},{"location":"about/benefits.html#2-reduced-operational-overhead","title":"\ud83d\udd39 2. Reduced Operational Overhead","text":"<ul> <li>Instead of manually crafting and applying YAMLs for each new namespace, admins define templates once and reuse them.  </li> <li>This greatly simplifies namespace onboarding and lifecycle management.</li> </ul>"},{"location":"about/benefits.html#3-separation-of-concerns","title":"\ud83d\udd39 3. Separation of Concerns","text":"<ul> <li>Platform teams manage templates (policies, guardrails, base configurations).  </li> <li>Application teams just request a namespace, and the operator ensures everything is provisioned consistently from the templates.  </li> </ul>"},{"location":"about/benefits.html#4-scalability","title":"\ud83d\udd39 4. Scalability","text":"<ul> <li>When you have tens or hundreds of namespaces, managing them manually is impossible.  </li> <li>Templates scale this by automating boilerplate generation.  </li> </ul>"},{"location":"about/benefits.html#5-governance-and-compliance","title":"\ud83d\udd39 5. Governance and Compliance","text":"<ul> <li>Templates allow embedding security controls (e.g., NetworkPolicies, PodSecurity, mandatory labels/annotations).  </li> <li>Ensures namespaces are created with guardrails from day one, reducing compliance drift.  </li> </ul>"},{"location":"about/benefits.html#6-gitops-friendly","title":"\ud83d\udd39 6. GitOps Friendly","text":"<ul> <li>Templates can be version-controlled and audited.  </li> <li>Any changes in the templates flow automatically to all affected namespaces when reconciled by the operator.  </li> </ul>"},{"location":"about/key-features.html","title":"Key Features","text":""},{"location":"about/key-features.html#key-features","title":"Key Features","text":"<p>The key features of Template Operator are described below.</p>"},{"location":"about/key-features.html#core-features","title":"Core Features","text":""},{"location":"about/key-features.html#templates-and-template-distribution","title":"Templates and Template distribution","text":"<p>Template Operator allows admins/users to define templates for namespaces, so that others can instantiate these templates to provision namespaces with batteries loaded. A template could pre-populate a namespace for certain use cases or with basic tooling required. Templates allow you to define Kubernetes manifests, Helm chart and more to be applied when the template is used to create a namespace.</p> <p>It also allows the parameterizing of these templates for flexibility and ease of use. It also provides the option to enforce the presence of templates in one tenant's or all the tenants' namespaces for configuring secure defaults.</p> <p>Common use cases for namespace templates may be:</p> <ul> <li>Adding networking policies for multitenancy</li> <li>Adding development tooling to a namespace</li> <li>Deploying pre-populated databases with test data</li> <li>Injecting new namespaces with optional credentials such as image pull secrets</li> </ul> <p>More details on Distributing Template Resources</p>"},{"location":"about/key-features.html#cross-namespace-resource-distribution","title":"Cross Namespace Resource Distribution","text":"<p>Template Operator supports cloning of secrets and ConfigMaps from one namespace to another namespace based on label selectors. It uses templates to enable users to provide reference to secrets and ConfigMaps. It uses a Cluster Template Instance to distribute those secrets and namespaces in matching namespaces, while Template Instance copies secret and configMap to a single namespace.</p> <p>More details on Copying Secrets and ConfigMaps</p>"},{"location":"about/key-features.html#operational-features","title":"Operational Features","text":""},{"location":"about/key-features.html#everything-as-codegitops-ready","title":"Everything as Code/GitOps Ready","text":"<p>Template Operator is designed and built to be 100% Kubernetes-native, and to be configured and managed the same familiar way as native Kubernetes resources so it's perfect for modern companies that are dedicated to GitOps as it is fully configurable using Custom Resources.</p>"},{"location":"about/key-features.html#native-experience","title":"Native Experience","text":"<p>Template Operator provides multi-tenancy with a native Kubernetes experience without introducing additional management layers, plugins, or customized binaries.</p>"},{"location":"architecture/architecture.html","title":"Architecture","text":""},{"location":"architecture/architecture.html#architecture","title":"Architecture","text":"<p>The Template Operator is a comprehensive system designed to manage multi-tenancy in Kubernetes environments. Following is the architecture of the Template Operator:</p> <p>Template Operator consists of multiple controllers and components that work together to provide the functionality of the system. The following is a list of the components that make up the Template Operator system:</p> Name Type Description Template Operator Manager Deployment The Template Operator Manager manages 3 different CRDs in one controller; Template, Template Instance and Cluster Template Instance. Template Operator Old Manager Deployment The Template Operator Old Manager manages older/legacy CRDs of the older version of operator, which were part of Multi Tenant Operator. It serves to handle older versions if needed during migration. Webhook Deployment The Webhook is responsible for managing webhook requests from Custom Resources."},{"location":"architecture/concepts.html","title":"Concepts","text":""},{"location":"architecture/concepts.html#concepts","title":"Concepts","text":"<p>Here are the key concepts of Template Operator:</p>"},{"location":"architecture/concepts.html#template","title":"Template","text":"<p>A Template is a reusable blueprint in Template Operator that defines configurations for Kubernetes resources. It supports raw manifests, gotemplate based dynamic manifests, Helm charts, or resource mappings, enabling standardization and automation across multiple tenants.</p>"},{"location":"architecture/concepts.html#template-instance-ti","title":"Template Instance (TI)","text":"<p>A Template Instance is a concrete implementation of a Template, created with specific parameters tailored for a particular tenant or use case. It generates actual Kubernetes resources based on the defined template.</p>"},{"location":"architecture/concepts.html#cluster-template-instance-cti","title":"Cluster Template Instance (CTI)","text":"<p>A Cluster Template Instance works on a particular set of namespaces based on the mentioned labels, taking Template as a reference for the resources to be deployed. It simplifies managing multiple interdependent resources for complex tenant setups.</p>"},{"location":"architecture/logs-metrics.html","title":"Metrics and Logs","text":""},{"location":"architecture/logs-metrics.html#metrics-and-logs","title":"Metrics and Logs","text":"<p>This document offers an overview of the Prometheus metrics implemented by the <code>template_operator</code> controllers, along with an interpretation guide for the logs and statuses generated by these controllers. Each metric is designed to provide specific insights into the controllers' operational performance, while the log interpretation guide aids in understanding their behavior and workflow processes. Additionally, the status descriptions for custom resources provide operational snapshots. Together, these elements form a comprehensive toolkit for monitoring and enhancing the performance and health of the controllers.</p>"},{"location":"architecture/logs-metrics.html#metrics-list","title":"Metrics List","text":"<p><code>template_operator_resources_deployed_total</code></p> <ul> <li>Description: Tracks the total number of resources deployed by the operator.</li> <li>Type: Gauge</li> <li>Labels: <code>kind</code>, <code>name</code>, <code>namespace</code></li> <li>Usage: Helps to understand the overall workload managed by the operator.</li> </ul> <p><code>template_operator_resources_deployed</code></p> <ul> <li>Description: Monitors resources currently deployed by the operator.</li> <li>Type: Gauge</li> <li>Labels: <code>kind</code>, <code>name</code>, <code>namespace</code>, <code>type</code></li> <li>Usage: Useful for tracking the current state and type of resources managed by the operator.</li> </ul> <p><code>template_operator_reconcile_error</code></p> <ul> <li>Description: Indicates resources in an error state, broken down by resource kind, name, and namespace.</li> <li>Type: Gauge</li> <li>Labels: <code>kind</code>, <code>name</code>, <code>namespace</code>, <code>state</code>, <code>errors</code></li> <li>Usage: Essential for identifying and analyzing errors in resource management.</li> </ul> <p><code>template_operator_reconcile_count</code></p> <ul> <li>Description: Counts the number of reconciliations performed for a Cluster Template Instance, categorized by name.</li> <li>Type: Gauge</li> <li>Labels: <code>kind</code>, <code>name</code></li> <li>Usage: Provides insight into the frequency of reconciliation processes.</li> </ul> <p><code>template_operator_reconcile_seconds</code></p> <ul> <li>Description: Represents the cumulative duration, in seconds, taken to reconcile a Cluster Template Instance, categorized by instance name.</li> <li>Type: Gauge</li> <li>Labels: <code>kind</code>, <code>name</code></li> <li>Usage: Critical for assessing the time efficiency of the reconciliation process.</li> </ul> <p><code>template_operator_reconcile_seconds_total</code></p> <ul> <li>Description: Tracks the total duration, in seconds, for all reconciliation processes of a Cluster Template Instance, categorized by instance name.</li> <li>Type: Gauge</li> <li>Labels: <code>kind</code>, <code>name</code></li> <li>Usage: Useful for understanding the overall time spent on reconciliation processes.</li> </ul>"},{"location":"architecture/logs-metrics.html#custom-resource-status","title":"Custom Resource Status","text":"<p>In this section, we delve into the status of various custom resources managed by our controllers. The <code>kubectl describe</code> command can be used to fetch the status of these resources.</p>"},{"location":"architecture/logs-metrics.html#cluster-template-instance","title":"Cluster Template Instance","text":"<p>Status from the <code>ClusterTemplateInstances.tenantoperator.stakater.com</code> custom resource:</p> <ul> <li>Current Operational State: Provides a snapshot of the resource's current condition.</li> <li>Conditions: Offers a detailed view of the resource's status, which includes:<ul> <li><code>InstallSucceeded</code>: Indicates the success of the instance's installation.</li> <li><code>Ready</code>: Shows the readiness of the instance, with details on the last reconciliation process, its duration, and relevant messages.</li> <li><code>Running</code>: Reports on active processes like ongoing resource reconciliation.</li> </ul> </li> <li>Deployed Namespaces: Enumerates the namespaces where the instance has been deployed, along with their statuses and associated template manifests.</li> <li>Manifest Hashes: Includes the <code>Template Manifests Hash</code> and <code>Resource Mapping Hash</code>, which provide versioning and change tracking for template manifests and resource mappings.</li> </ul>"},{"location":"architecture/logs-metrics.html#log-interpretation-guide","title":"Log Interpretation Guide","text":""},{"location":"architecture/logs-metrics.html#cluster-template-instance-controller","title":"Cluster Template Instance Controller","text":"<p>Logs from the <code>tenant-operator-ClusterTemplateInstance-controller</code>:</p> <ul> <li>Reconciliation Process: Logs starting with <code>Reconciling!</code> mark the beginning of a reconciliation process for a ClusterTemplateInstance. Subsequent actions like <code>Creating/Updating ClusterTemplateInstance</code> and <code>Retrieving list of namespaces Matching to TGI</code> outline the reconciliation steps.</li> <li>Namespace and Resource Management: Logs such as <code>Namespaces test-namespace-1 is new or failed...</code> and <code>Creating/Updating resource...</code> detail the management of Kubernetes resources in specific namespaces.</li> <li>Worker Activities: Logs labeled <code>[Worker X]</code> show tasks being processed in parallel, including steps like <code>Validating parameters</code>, <code>Gathering objects from manifest</code>, and <code>Apply manifests</code>.</li> <li>Reconciliation Completion: Entries like <code>End Reconciling</code> and <code>Defering XXth Reconciling, with duration XXXms</code> indicate the end of a reconciliation process and its duration, aiding in performance analysis.</li> <li>Watcher Events: Logs from <code>Watcher</code> such as <code>Delete call received for object...</code> and <code>Following resource is recreated...</code> are key for tracking changes to Kubernetes objects.</li> </ul> <p>These logs are crucial for tracking the system's behavior, diagnosing issues, and comprehending the resource management workflow.</p>"},{"location":"installation/kubernetes.html","title":"On Kubernetes","text":""},{"location":"installation/kubernetes.html#on-kubernetes","title":"On Kubernetes","text":"<p>This document contains instructions on installing, uninstalling and configuring Multi Tenant Operator on Kubernetes.</p> <ol> <li> <p>Installing via Helm CLI</p> </li> <li> <p>Uninstall</p> </li> </ol>"},{"location":"installation/kubernetes.html#requirements","title":"Requirements","text":"<ul> <li>A Kubernetes cluster (v1.24 or higher)</li> <li>Helm CLI</li> <li>kubectl</li> <li>To run on Kubernetes, Template Operator relies on Cert Manager and its Certificate CRs to create <code>TLS</code> secrets for webhooks, these certificates will be handled by templates in Helm Chart</li> </ul>"},{"location":"installation/kubernetes.html#installing-via-helm-cli","title":"Installing via Helm CLI","text":"<ul> <li> <p>Public Helm Chart of Template Operator is available at Stakater ghcr Packages</p> </li> <li> <p>Use <code>helm install</code> command to install Template Operator helm chart.</p> </li> </ul> <pre><code>helm install template-operator oci://ghcr.io/stakater/public/charts/template-operator --namespace template-operator-system --create-namespace\n</code></pre> <p>Note</p> <p>It is better to install Template Operator in its preferred namespace, <code>template-operator-system</code></p> <p>Wait for the pods to be up</p> <pre><code>kubectl get pods -n template-operator-system --watch\n</code></pre>"},{"location":"installation/kubernetes.html#uninstall-via-helm-cli","title":"Uninstall via Helm CLI","text":"<p>Template Operator can be uninstalled by Helm CLI if Helm was used to install it earlier.</p> <ul> <li>Use <code>helm uninstall</code> command to remove the earlier created <code>Helm Release</code> in <code>template-operator-system</code> namespace</li> </ul> <pre><code>helm uninstall template-operator --namespace template-operator-system\n</code></pre>"},{"location":"installation/openshift.html","title":"On OpenShift","text":""},{"location":"installation/openshift.html#on-openshift","title":"On OpenShift","text":"<p>Template Operator is RedHat Certified operator available on the Red Hat MarketPlace.</p> <p>This document contains instructions on installing, uninstalling and configuring Multi Tenant Operator on OpenShift.</p> <ol> <li> <p>OpenShift OperatorHub UI</p> </li> <li> <p>CLI/GitOps</p> </li> <li> <p>Uninstall</p> </li> </ol>"},{"location":"installation/openshift.html#requirements","title":"Requirements","text":"<ul> <li>An OpenShift cluster</li> </ul>"},{"location":"installation/openshift.html#installing-via-operatorhub-ui","title":"Installing via OperatorHub UI","text":"<ul> <li>After opening OpenShift console click on <code>Operators</code>, followed by <code>OperatorHub</code> from the side menu</li> </ul> <ul> <li>Now search for <code>Template Operator</code> and then click on <code>Template Operator</code> tile</li> </ul> <ul> <li>Click on the <code>install</code> button</li> </ul> <ul> <li>Keep the <code>Update Channel</code> and <code>Version</code> dropdowns at the latest versions. Select Operator recommended Namespace in <code>Installed Namespace</code> section.</li> </ul> <ul> <li>Wait for the operator to be installed</li> </ul> <p>Note: Template Operator will be installed in <code>template-operator-system</code> namespace.</p>"},{"location":"installation/openshift.html#installing-via-cli-or-gitops","title":"Installing via CLI OR GitOps","text":"<ul> <li>Create namespace <code>template-operator-system</code></li> </ul> <pre><code>oc create namespace template-operator-system\nnamespace/template-operator-system created\n</code></pre> <ul> <li>Create an OperatorGroup YAML for Template Operator and apply it in <code>template-operator-system</code> namespace.</li> </ul> <pre><code>oc create -f - &lt;&lt; EOF\napiVersion: operators.coreos.com/v1\nkind: OperatorGroup\nmetadata:\n  name: template-operator\n  namespace: template-operator-system\nEOF\noperatorgroup.operators.coreos.com/template-operator created\n</code></pre> <ul> <li>Create a subscription YAML for Template Operator and apply it in <code>template-operator-system</code> namespace.</li> </ul> <pre><code>oc create -f - &lt;&lt; EOF\napiVersion: operators.coreos.com/v1alpha1\nkind: Subscription\nmetadata:\n  name: template-operator\n  namespace: template-operator-system\nspec:\n  channel: release-0.1\n  installPlanApproval: Automatic\n  name: template-operator\n  source: certified-operators\n  sourceNamespace: openshift-marketplace\n  startingCSV: template-operator.v0.1.5\nEOF\nsubscription.operators.coreos.com/template-operator created\n</code></pre> <p>Note: To bring Template Operator via GitOps, add the above files in GitOps repository.</p> <ul> <li>After creating the <code>subscription</code> custom resource, open OpenShift console and click on <code>Operators</code>, followed by <code>Installed Operators</code> from the side menu and wait for the installation to complete</li> </ul> <p></p>"},{"location":"installation/openshift.html#uninstall-via-operatorhub-ui","title":"Uninstall via OperatorHub UI","text":"<p>You can uninstall Template Operator by following these steps:</p> <ul> <li>After making the required changes open OpenShift console and click on <code>Operators</code>, followed by <code>Installed Operators</code> from the side menu</li> </ul> <p></p> <ul> <li>Now click on uninstall and confirm uninstall.</li> </ul> <p></p> <ul> <li>Now the operator has been uninstalled.</li> </ul> <p>Note: you can also manually remove Template Operator's CRDs and its resources from the cluster.</p>"},{"location":"installation/overview.html","title":"Overview","text":""},{"location":"installation/overview.html#overview","title":"Overview","text":"<p>The Multi-Tenant Operator (Template Operator) supports two installation methods: Operator Lifecycle Manager (OLM) and Helm Chart. These methods ensure flexibility and compatibility across various Kubernetes environments, including OpenShift, Azure Kubernetes Service (AKS), Amazon Elastic Kubernetes Service (EKS), and others.</p>"},{"location":"installation/overview.html#installation-methods","title":"Installation Methods","text":""},{"location":"installation/overview.html#1-operator-lifecycle-manager-olm","title":"1. Operator Lifecycle Manager (OLM)","text":"<p>OLM is the recommended installation method for OpenShift. It leverages OpenShift's native operator management capabilities, ensuring seamless integration and lifecycle management.</p>"},{"location":"installation/overview.html#2-helm-chart","title":"2. Helm Chart","text":"<p>Helm is the preferred installation method for all other Kubernetes distributions, including AKS, EKS, GKE and generic Kubernetes environments. Helm simplifies the deployment process with its consistent and automated approach.</p>"},{"location":"installation/overview.html#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure the following:</p> <ul> <li>Access to an OpenShift cluster (for OLM installation) or a Kubernetes cluster (for Helm installation).</li> <li>Administrator-level permissions on the cluster.</li> <li>Familiarity with kubectl or platform-specific CLI tools.</li> <li>Helm installed locally for Helm-based installations.</li> </ul>"},{"location":"installation/overview.html#next-steps","title":"Next Steps","text":"<p>Choose the installation guide that matches your environment:</p> <ul> <li>Installing with OLM on OpenShift</li> <li>Installing with Helm on any Kubernetes</li> </ul> <p>By following the appropriate guide, you\u2019ll be able to deploy Template Operator efficiently and start managing multi-tenancy in your Kubernetes environment.</p>"},{"location":"kubernetes-resources/cluster-template-instance.html","title":"ClusterTemplateInstance","text":""},{"location":"kubernetes-resources/cluster-template-instance.html#clustertemplateinstance","title":"ClusterTemplateInstance","text":"<p>Cluster scoped resource:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: namespace-parameterized-restrictions-tgi\nspec:\n  template: namespace-parameterized-restrictions\n  sync: true\n  selector:\n    matchExpressions:\n    - key: stakater.com/tenant\n      operator: In\n      values:\n        - alpha\n        - beta\n  parameters:\n    - name: CIDR_IP\n      value: \"172.17.0.0/16\"\n</code></pre> <p>ClusterTemplateInstance distributes a template across multiple namespaces which are selected by labelSelector.</p>"},{"location":"kubernetes-resources/template-instance.html","title":"TemplateInstance","text":""},{"location":"kubernetes-resources/template-instance.html#templateinstance","title":"TemplateInstance","text":"<p>Namespace scoped resource:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\n  name: networkpolicy\n  namespace: build\nspec:\n  template: networkpolicy\n  sync: true\n  parameters:\n    - name: CIDR_IP\n      value: \"172.17.0.0/16\"\n</code></pre> <p>TemplateInstance are used to keep track of resources created from Templates, which are being instantiated inside a Namespace. Generally, a TemplateInstance is created from a Template and then the TemplateInstances will not be updated when the Template changes later on. To change this behavior, it is possible to set <code>spec.sync: true</code> in a TemplateInstance. Setting this option, means to keep this TemplateInstance in sync with the underlying template (similar to Helm upgrade).</p>"},{"location":"kubernetes-resources/template.html","title":"Template","text":""},{"location":"kubernetes-resources/template.html#template","title":"Template","text":"<p>Templates are used to initialize Namespaces, share common resources across namespaces, and map secrets/ConfigMaps from one namespace to other namespaces.</p> <p>They can contain pre-defined parameters such as <code>${namespace}</code>/<code>${tenant}</code>.</p> <p>Also, you can define custom variables in <code>Template</code>, <code>TemplateInstance</code> and <code>ClusterTemplateInstance</code>. The parameters defined in <code>Templates</code> are overwritten the values defined in <code>TemplateInstance</code> and <code>ClusterTemplateInstance</code>.</p>"},{"location":"kubernetes-resources/template.html#specification","title":"Specification","text":"<p><code>Template</code> Custom Resource (CR) supports three key methods for defining and managing resources: <code>manifests</code>, <code>helm</code>, <code>gotemplate</code>, and <code>resource mapping</code>. Let\u2019s dive into each method, their differences, and their use cases:</p>"},{"location":"kubernetes-resources/template.html#1-manifests","title":"1. Manifests","text":"<p>This approach uses raw Kubernetes manifests (YAML files) that specify resources directly in the template.</p>"},{"location":"kubernetes-resources/template.html#how-it-works","title":"How It Works","text":"<ul> <li>The template includes the actual YAML specifications of resources like <code>Deployment</code>, <code>Service</code>, <code>ConfigMap</code>, etc.</li> <li>These manifests are applied as-is or with minor parameter substitutions (e.g., dynamically populated <code>{tenant}</code> and <code>{namespace}</code> variables wherever added or user defined parameters).</li> </ul>"},{"location":"kubernetes-resources/template.html#use-cases","title":"Use Cases","text":"<ul> <li>Best for straightforward and simple resources where you don't need advanced templating logic or dependency management.</li> <li>Ideal when the resource definitions are static or have minimal customization needs.</li> </ul>"},{"location":"kubernetes-resources/template.html#example","title":"Example","text":"<pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: networkpolicy\nparameters:\n  - name: CIDR_IP\n    value: \"172.17.0.0/16\"\nresources:\n  manifests:\n    - kind: NetworkPolicy\n      apiVersion: networking.k8s.io/v1\n      metadata:\n        name: deny-cross-ns-traffic\n      spec:\n        podSelector:\n          matchLabels:\n            role: db\n        policyTypes:\n        - Ingress\n        - Egress\n        ingress:\n        - from:\n          - ipBlock:\n              cidr: \"${{CIDR_IP}}\"\n              except:\n              - 172.17.1.0/24\n          - namespaceSelector:\n              matchLabels:\n                project: myproject\n          - podSelector:\n              matchLabels:\n                role: frontend\n          ports:\n          - protocol: TCP\n            port: 6379\n        egress:\n        - to:\n          - ipBlock:\n              cidr: 10.0.0.0/24\n          ports:\n          - protocol: TCP\n            port: 5978\n</code></pre>"},{"location":"kubernetes-resources/template.html#2-helm","title":"2. Helm","text":"<p>This method integrates Helm charts into the template, allowing you to leverage Helm's templating capabilities and package management.</p>"},{"location":"kubernetes-resources/template.html#how-it-works_1","title":"How It Works","text":"<ul> <li>The <code>Template</code> references a Helm chart.</li> <li>Values for the Helm chart can be passed by the <code>values</code> field.</li> <li>The Helm chart generates the necessary Kubernetes resources dynamically at runtime.</li> </ul>"},{"location":"kubernetes-resources/template.html#use-cases_1","title":"Use Cases","text":"<ul> <li>Best for complex resource setups with interdependencies (e.g., a microservice with a Deployment, Service, Ingress, and ConfigMap).</li> <li>Useful for resources requiring advanced templating logic or modular packaging.</li> <li>Great for managing third-party tools or applications (e.g., deploying Prometheus, Keycloak, or databases).</li> </ul>"},{"location":"kubernetes-resources/template.html#example_1","title":"Example","text":"<pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: redis\nresources:\n  helm:\n    releaseName: redis\n    chart:\n      repository:\n        name: redis\n        version: 14.6.0\n        repoUrl: https://charts.bitnami.com/bitnami\n        username:\n          key: username\n          name: redis-creds\n          namespace: namespace-n1\n        password:\n          key: password\n          name: redis-creds\n          namespace: namespace-n1\n    setValues:\n      - name: port\n        value: '6379'\n        forceString: false\n    values: |\n      redisPort: 6379\n</code></pre> <p>A brief explanation of the fields in the Helm section:</p> <ul> <li><code>releaseName</code>: The name of the Helm release.</li> <li><code>chart</code>: The Helm chart details.<ul> <li><code>repository</code>: The Helm repository details.<ul> <li><code>name</code>: The name of the Helm repository.</li> <li><code>version</code>: The version of the Helm chart.</li> <li><code>repoUrl</code>: The URL of the Helm repository.</li> </ul> </li> <li><code>username</code>: A reference to the secret containing the username for the Helm repository in case the chart is in a private repository.<ul> <li><code>key</code>: The key in the secret containing the username.</li> <li><code>name</code>: The name of the secret containing the username.</li> <li><code>namespace</code>: The namespace of the secret containing the username.</li> </ul> </li> <li><code>password</code>: A reference to the secret containing the password for the Helm repository in case the chart is in a private repository.<ul> <li><code>key</code>: The key in the secret containing the password.</li> <li><code>name</code>: The name of the secret containing the password.</li> <li><code>namespace</code>: The namespace of the secret containing the password.</li> </ul> </li> </ul> </li> <li><code>setValues</code>: The values to set in the Helm chart.<ul> <li><code>name</code>: The name of the value.</li> <li><code>value</code>: The value to set.</li> <li><code>forceString</code>: Whether to use <code>--set</code> or <code>--set-string</code> when setting the value. Default is <code>false</code> (use <code>--set</code>).</li> </ul> </li> <li><code>values</code>: The values file for the Helm chart.</li> </ul>"},{"location":"kubernetes-resources/template.html#3-gotemplate","title":"3. GoTemplate","text":"<p>This method uses inline Go templates to dynamically generate Kubernetes manifests. It leverages Go\u2019s <code>text/template</code> syntax along with Sprig functions for string operations, date formatting, conditionals, arithmetic, and more.</p>"},{"location":"kubernetes-resources/template.html#how-it-works_2","title":"How It Works","text":"<ul> <li>The <code>gotemplate</code> section contains YAML written with Go template expressions such as <code>{{ .Name }}</code> or <code>{{ now | date \"2006-01-02\" }}</code>.</li> <li>Template <code>parameters</code> are injected at runtime, and Sprig functions can be used to transform or compute values.</li> <li>The rendered output must be valid Kubernetes YAML, which the operator then applies to the target namespaces.</li> </ul>"},{"location":"kubernetes-resources/template.html#use-cases_2","title":"Use Cases","text":"<ul> <li>Ideal for dynamic resource generation without maintaining a full Helm chart.</li> <li>Useful when you need lightweight templating with conditional or computed fields.</li> <li>Suitable for resources that change based on tenant, namespace, or environment attributes.</li> </ul>"},{"location":"kubernetes-resources/template.html#example_2","title":"Example","text":"<pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: inline-gotemplate\nparameters:\n  - name: Name\n    value: \"sample-App\"\n  - name: LogLevel\n    value: \"INFO\"\nresources:\n  gotemplate: |\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: \"{{ .Name | lower }}-config\"\n      labels:\n        app: \"{{ .Name | lower }}\"\n    data:\n      appName: \"{{ .Name }}\"\n      logLevel: \"{{ .LogLevel }}\"\n      configVersion: \"{{ now | date \"2006-01-02\" }}\"\n</code></pre>"},{"location":"kubernetes-resources/template.html#4-resource-mapping","title":"4. Resource Mapping","text":"<p>This approach maps secrets and ConfigMaps from one tenant's namespace to another tenant's namespace, or within a tenant's namespace.</p>"},{"location":"kubernetes-resources/template.html#how-it-works_3","title":"How It Works","text":"<ul> <li>The template contains mappings to pre-existing resources (secrets and ConfigMaps only).</li> </ul>"},{"location":"kubernetes-resources/template.html#use-cases_3","title":"Use Cases","text":"<ul> <li>Ideal for maintaining consistency across shared resources without duplicating definitions.</li> <li>Best when resources already exist.</li> </ul>"},{"location":"kubernetes-resources/template.html#example_3","title":"Example","text":"<pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: resource-mapping\nresources:\n  resourceMappings:\n    secrets:\n      - name: secret-s1\n        namespace: namespace-n1\n    configMaps:\n      - name: configmap-c1\n        namespace: namespace-n2\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/copying-resources-2.html","title":"Copying Secrets and ConfigMaps across Tenant Namespaces via TGI","text":""},{"location":"kubernetes-resources/how-to-guides/copying-resources-2.html#copying-secrets-and-configmaps-across-tenant-namespaces-via-tgi","title":"Copying Secrets and ConfigMaps across Tenant Namespaces via TGI","text":"<p>Bill is a cluster admin who wants to map a <code>docker-pull-secret</code>, present in a <code>build</code> namespace, in tenant namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: docker-pull-secret\nresources:\n  resourceMappings:\n    secrets:\n      - name: docker-pull-secret\n        namespace: build\n</code></pre> <p>Once the template has been created, Bill makes a <code>ClusterTemplateInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: docker-secret-group-instance\nspec:\n  template: docker-pull-secret\n  selector:\n    matchLabels:\n      kind: build\n  sync: true\n</code></pre> <p>Afterward, Bill can see that secrets has been successfully mapped in all matching namespaces.</p> <pre><code>kubectl get secret docker-pull-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n\nkubectl get secret docker-pull-secret -n alpha-dave-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/copying-resources-2.html#mapping-resources-within-tenant-namespaces-via-ti","title":"Mapping Resources within Tenant Namespaces via TI","text":"<p>Anna is a tenant owner who wants to map a <code>docker-pull-secret</code>, present in <code>bluseky-build</code> namespace, to <code>bluesky-anna-aurora-sandbox</code> namespace.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: docker-pull-secret\nresources:\n  resourceMappings:\n    secrets:\n      - name: docker-pull-secret\n        namespace: bluesky-build\n</code></pre> <p>Once the template has been created, Anna creates a <code>TemplateInstance</code> in <code>bluesky-anna-aurora-sandbox</code> namespace, referring to the <code>Template</code>.</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\n  name: docker-secret-instance\n  namespace: bluesky-anna-aurora-sandbox\nspec:\n  template: docker-pull-secret\n  sync: true\n</code></pre> <p>Afterward, Bill can see that secrets has been successfully mapped in all matching namespaces.</p> <pre><code>kubectl get secret docker-pull-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/copying-resources.html","title":"Propagate Secrets from Parent to Descendant namespaces","text":""},{"location":"kubernetes-resources/how-to-guides/copying-resources.html#propagate-secrets-from-parent-to-descendant-namespaces","title":"Propagate Secrets from Parent to Descendant namespaces","text":"<p>Secrets like <code>registry</code> credentials often need to exist in multiple Namespaces, so that Pods within different namespaces can have access to those credentials in form of secrets.</p> <p>Manually creating secrets within different namespaces could lead to challenges, such as:</p> <ul> <li>Someone will have to create secret either manually or via GitOps each time there is a new descendant namespace that needs the secret</li> <li>If we update the parent secret, they will have to update the secret in all descendant namespaces</li> <li>This could be time-consuming, and a small mistake while creating or updating the secret could lead to unnecessary debugging</li> </ul> <p>With the help of Template Operator's Template feature we can make this secret distribution experience easy.</p> <p>For example, to copy a Secret called <code>registry</code> which exists in the <code>example</code> to new Namespaces whenever they are created, we will first create a Template which will have reference of the registry secret.</p> <p>It will also push updates to the copied Secrets and keep the propagated secrets always sync and updated with parent namespaces.</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: registry-secret\nresources:\n  resourceMappings:\n    secrets:\n      - name: registry\n        namespace: example\n</code></pre> <p>Now using this Template we can propagate registry secret to different namespaces that have some common set of labels.</p> <p>For example, will just add one label <code>kind: registry</code> and all namespaces with this label will get this secret.</p> <p>For propagating it on different namespaces dynamically will have to create another resource called <code>ClusterTemplateInstance</code>. <code>ClusterTemplateInstance</code> will have <code>Template</code> and <code>matchLabel</code> mapping as shown below:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: registry-secret-group-instance\nspec:\n  template: registry-secret\n  selector:\n    matchLabels:\n      kind: registry\n  sync: true\n</code></pre> <p>After reconciliation, you will be able to see those secrets in namespaces having mentioned label.</p> <p>Template Operator will keep injecting this secret to the new namespaces created with that label.</p> <pre><code>kubectl get secret registry-secret -n example-ns-1\nNAME             STATE    AGE\nregistry-secret    Active   3m\n\nkubectl get secret registry-secret -n example-ns-2\nNAME             STATE    AGE\nregistry-secret    Active   3m\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/deploying-private-helm-charts.html","title":"Deploying Private Helm Chart to Multiple Namespaces","text":""},{"location":"kubernetes-resources/how-to-guides/deploying-private-helm-charts.html#deploying-private-helm-chart-to-multiple-namespaces","title":"Deploying Private Helm Chart to Multiple Namespaces","text":"<p>Multi Tenant Operator uses its <code>helm</code> functionality from <code>Template</code> and <code>ClusterTemplateInstance</code> to deploy private and public charts to multiple namespaces.</p>"},{"location":"kubernetes-resources/how-to-guides/deploying-private-helm-charts.html#deploying-helm-chart-to-namespaces-via-clustertemplateinstances-from-oci-registry","title":"Deploying Helm Chart to Namespaces via ClusterTemplateInstances from OCI Registry","text":"<p>Bill, the cluster admin, wants to deploy a helm chart from <code>OCI</code> registry in namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: chart-deploy\nresources:\n  helm:\n    releaseName: random-release\n    chart:\n      repository:\n        name: random-chart\n        repoUrl: \"oci://ghcr.io/stakater/charts/random-chart\"\n        version: 0.0.15\n        password:\n          key: password\n          name: repo-user\n          namespace: shared-ns\n        username:\n          key: username\n          name: repo-user\n          namespace: shared-ns\n</code></pre> <p>Once the template has been created, Bill makes a <code>ClusterTemplateInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: chart-deploy\nspec:\n  selector:\n    matchExpressions:\n      - key: stakater.com/kind\n        operator: In\n        values:\n          - system\n  sync: true\n  template: chart-deploy\n</code></pre> <p>Multi Tenant Operator will pick up the credentials from the mentioned namespace to pull the chart and apply it.</p> <p>Afterward, Bill can see that manifests in the chart have been successfully created in all label matching namespaces.</p>"},{"location":"kubernetes-resources/how-to-guides/deploying-private-helm-charts.html#deploying-helm-chart-to-namespaces-via-clustertemplateinstances-from-https-registry","title":"Deploying Helm Chart to Namespaces via ClusterTemplateInstances from <code>HTTPS</code> Registry","text":"<p>Bill, the cluster admin, wants to deploy a helm chart from <code>HTTPS</code> registry in namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: chart-deploy\nresources:\n  helm:\n    releaseName: random-release\n    chart:\n      repository:\n        name: random-chart\n        repoUrl: 'nexus-helm-url/registry'\n        version: 0.0.15\n        password:\n          key: password\n          name: repo-user\n          namespace: shared-ns\n        username:\n          key: username\n          name: repo-user\n          namespace: shared-ns\n</code></pre> <p>Once the template has been created, Bill makes a <code>ClusterTemplateInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: chart-deploy\nspec:\n  selector:\n    matchExpressions:\n      - key: stakater.com/kind\n        operator: In\n        values:\n          - system\n  sync: true\n  template: chart-deploy\n</code></pre> <p>Multi Tenant Operator will pick up the credentials from the mentioned namespace to pull the chart and apply it.</p> <p>Afterward, Bill can see that manifests in the chart have been successfully created in all label matching namespaces.</p>"},{"location":"kubernetes-resources/how-to-guides/deploying-templates.html","title":"Distributing Resources in Namespaces","text":""},{"location":"kubernetes-resources/how-to-guides/deploying-templates.html#distributing-resources-in-namespaces","title":"Distributing Resources in Namespaces","text":"<p>Multi Tenant Operator has two Custom Resources which can cover this need using the <code>Template</code> CR, depending upon the conditions and preference.</p> <ol> <li>ClusterTemplateInstance</li> <li>TemplateInstance</li> </ol>"},{"location":"kubernetes-resources/how-to-guides/deploying-templates.html#deploying-template-to-namespaces-via-clustertemplateinstances","title":"Deploying Template to Namespaces via ClusterTemplateInstances","text":"<p>Bill, the cluster admin, wants to deploy a docker pull secret in namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: docker-secret\nresources:\n  manifests:\n    - kind: Secret\n      apiVersion: v1\n      metadata:\n        name: docker-pull-secret\n      data:\n        .dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\n      type: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Bill makes a <code>ClusterTemplateInstance</code> referring to the <code>Template</code> he wants to deploy with <code>MatchLabels</code>:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: docker-secret-group-instance\nspec:\n  template: docker-secret\n  selector:\n    matchLabels:\n      kind: build\n  sync: true\n</code></pre> <p>Afterward, Bill can see that secrets have been successfully created in all label matching namespaces.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   3m\n\nkubectl get secret docker-secret -n alpha-dave-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   2m\n</code></pre> <p><code>ClusterTemplateInstance</code> can also target specific tenants or all tenant namespaces under a single YAML definition.</p>"},{"location":"kubernetes-resources/how-to-guides/deploying-templates.html#clustertemplateinstance-for-multiple-tenants","title":"ClusterTemplateInstance for multiple Tenants","text":"<p>It can be done by using the <code>matchExpressions</code> field, dividing the tenant label in key and values.</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: docker-secret-group-instance\nspec:\n  template: docker-secret\n  selector:\n    matchExpressions:\n    - key: stakater.com/tenant\n      operator: In\n      values:\n        - alpha\n        - beta\n  sync: true\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/deploying-templates.html#clustertemplateinstance-for-all-tenants","title":"ClusterTemplateInstance for all Tenants","text":"<p>This can also be done by using the <code>matchExpressions</code> field, using just the tenant label key <code>stakater.com/tenant</code>.</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: docker-secret-group-instance\nspec:\n  template: docker-secret\n  selector:\n    matchExpressions:\n    - key: stakater.com/tenant\n      operator: Exists\n  sync: true\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/deploying-templates.html#deploying-template-to-a-namespace-via-templateinstance","title":"Deploying Template to a Namespace via TemplateInstance","text":"<p>Anna wants to deploy a docker pull secret in her namespace.</p> <p>First Anna asks Bill, the cluster admin, to create a template of the secret for her:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: docker-pull-secret\nresources:\n  manifests:\n    - kind: Secret\n      apiVersion: v1\n      metadata:\n        name: docker-pull-secret\n      data:\n        .dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\n      type: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Anna creates a <code>TemplateInstance</code> in her namespace referring to the <code>Template</code> she wants to deploy:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\n  name: docker-pull-secret-instance\n  namespace: bluesky-anna-aurora-sandbox\nspec:\n  template: docker-pull-secret\n  sync: true\n</code></pre> <p>Once this is created, Anna can see that the secret has been successfully applied.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME                  STATE    AGE\ndocker-pull-secret    Active   3m\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/deploying-templates.html#passing-parameters-to-template-via-templateinstance-clustertemplateinstance","title":"Passing Parameters to Template via TemplateInstance, ClusterTemplateInstance","text":"<p>Anna wants to deploy a LimitRange resource to certain namespaces.</p> <p>First Anna asks Bill, the cluster admin, to create template with parameters for LimitRange for her:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: namespace-parameterized-restrictions\nparameters:\n  # Name of the parameter\n  - name: DEFAULT_CPU_LIMIT\n    # The default value of the parameter\n    value: \"1\"\n  - name: DEFAULT_CPU_REQUESTS\n    value: \"0.5\"\n    # If a parameter is required the template instance will need to set it\n    # required: true\n    # Make sure only values are entered for this parameter\n    validation: \"^[0-9]*\\\\.?[0-9]+$\"\nresources:\n  manifests:\n    - apiVersion: v1\n      kind: LimitRange\n      metadata:\n        name: namespace-limit-range-${namespace}\n      spec:\n        limits:\n          - default:\n              cpu: \"${{DEFAULT_CPU_LIMIT}}\"\n            defaultRequest:\n              cpu: \"${{DEFAULT_CPU_REQUESTS}}\"\n            type: Container\n</code></pre> <p>Afterward, Anna creates a <code>TemplateInstance</code> in her namespace referring to the <code>Template</code> she wants to deploy:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: TemplateInstance\nmetadata:\n  name: namespace-parameterized-restrictions-instance\n  namespace: bluesky-anna-aurora-sandbox\nspec:\n  template: namespace-parameterized-restrictions\n  sync: true\n  parameters:\n    - name: DEFAULT_CPU_LIMIT\n      value: \"1.5\"\n    - name: DEFAULT_CPU_REQUESTS\n      value: \"1\"\n</code></pre> <p>If she wants to distribute the same Template over multiple namespaces, she can use <code>ClusterTemplateInstance</code>.</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: namespace-parameterized-restrictions-tgi\nspec:\n  template: namespace-parameterized-restrictions\n  sync: true\n  selector:\n    matchExpressions:\n    - key: stakater.com/tenant\n      operator: In\n      values:\n        - alpha\n        - beta\n  parameters:\n    - name: DEFAULT_CPU_LIMIT\n      value: \"1.5\"\n    - name: DEFAULT_CPU_REQUESTS\n      value: \"1\"\n</code></pre>"},{"location":"kubernetes-resources/how-to-guides/distributing-manifests.html","title":"Distributing Resources in Namespaces","text":""},{"location":"kubernetes-resources/how-to-guides/distributing-manifests.html#distributing-resources-in-namespaces","title":"Distributing Resources in Namespaces","text":"<p>Multi Tenant Operator has two Custom Resources which can cover this need using the <code>Template</code> CR, depending upon the conditions and preference.</p> <ol> <li>ClusterTemplateInstance</li> <li>TemplateInstance</li> </ol>"},{"location":"kubernetes-resources/how-to-guides/distributing-manifests.html#deploying-template-to-namespaces-via-clustertemplateinstances","title":"Deploying Template to Namespaces via ClusterTemplateInstances","text":"<p>Bill, the cluster admin, wants to deploy a docker pull secret in namespaces where certain labels exists.</p> <p>First, Bill creates a template:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: docker-secret\nresources:\n  manifests:\n    - kind: Secret\n      apiVersion: v1\n      metadata:\n        name: docker-pull-secret\n      data:\n        .dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\n      type: kubernetes.io/dockercfg\n</code></pre> <p>Once the template has been created, Bill makes a <code>ClusterTemplateInstance</code> referring to the <code>Template</code> he wants to deploy with <code>template</code> field, and the namespaces where resources are needed, using <code>selector</code> field:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: docker-secret-group-instance\nspec:\n  template: docker-pull-secret\n  selector:\n    matchExpressions:\n    - key: kind\n      operator: In\n      values:\n        - build\n  sync: true\n</code></pre> <p>Afterward, Bill can see that secrets have been successfully created in all label matching namespaces.</p> <pre><code>kubectl get secret docker-secret -n bluesky-anna-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   3m\n\nkubectl get secret docker-secret -n alpha-dave-aurora-sandbox\nNAME             STATE    AGE\ndocker-secret    Active   2m\n</code></pre> <p><code>ClusterTemplateInstance</code> can also target specific tenants or all tenant namespaces under a single YAML definition.</p>"},{"location":"kubernetes-resources/how-to-guides/distributing-secrets-using-sealed-secret-template.html","title":"Distributing Secrets Using Sealed Secrets Template","text":""},{"location":"kubernetes-resources/how-to-guides/distributing-secrets-using-sealed-secret-template.html#distributing-secrets-using-sealed-secrets-template","title":"Distributing Secrets Using Sealed Secrets Template","text":"<p>Bill is a cluster admin who wants to provide a mechanism for distributing secrets in multiple namespaces. For this, he wants to use Sealed Secrets as the solution by adding them to Template Operator Template CR</p> <p>First, Bill creates a Template in which Sealed Secret is mentioned:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: tenant-sealed-secret\nresources:\n  manifests:\n  - kind: SealedSecret\n    apiVersion: bitnami.com/v1alpha1\n    metadata:\n      name: mysecret\n    spec:\n      encryptedData:\n        .dockerconfigjson: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEq.....\n      template:\n        type: kubernetes.io/dockerconfigjson\n        # this is an example of labels and annotations that will be added to the output secret\n        metadata:\n          labels:\n            \"jenkins.io/credentials-type\": usernamePassword\n          annotations:\n            \"jenkins.io/credentials-description\": credentials from Kubernetes\n</code></pre> <p>Once the template has been created, Bill has to put unique label on namespaces in which the secrets have to be deployed.</p> <p>Bill has added support for a new label <code>distribute-image-pull-secret: true</code> for tenant projects/namespaces, now Template Operator will add that label depending on the used field.</p> <p>Finally, Bill creates a <code>ClusterTemplateInstance</code> which will deploy the Sealed Secrets using the newly created project label and template:</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: tenant-sealed-secret\nspec:\n  template: tenant-sealed-secret\n  selector:\n    matchLabels:\n      distribute-image-pull-secret: true\n  sync: true\n</code></pre> <p>Template Operator will now deploy the Sealed Secrets mentioned in <code>Template</code> to namespaces which have the mentioned label. The rest of the work to deploy secret from a Sealed Secret has to be done by Sealed Secrets Controller.</p>"},{"location":"kubernetes-resources/how-to-guides/resource-sync-by-tgi.html","title":"Sync Resources Deployed by ClusterTemplateInstance","text":""},{"location":"kubernetes-resources/how-to-guides/resource-sync-by-tgi.html#sync-resources-deployed-by-clustertemplateinstance","title":"Sync Resources Deployed by ClusterTemplateInstance","text":"<p>The ClusterTemplateInstance CR provides two types of resource sync for the resources mentioned in Template</p> <p>For the given example, let's consider we want to apply the following template</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: docker-secret\nresources:\n  manifests:\n\n    - kind: Secret\n      apiVersion: v1\n      metadata:\n        name: docker-pull-secret\n      data:\n        .dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\n      type: kubernetes.io/dockercfg\n\n    - apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: example-automated-thing\n      secrets:\n        - name: example-automated-thing-token-zyxwv\n</code></pre> <p>And the following ClusterTemplateInstance is used to deploy these resources to namespaces having label <code>kind: build</code></p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: ClusterTemplateInstance\nmetadata:\n  name: docker-secret-group-instance\nspec:\n  template: docker-secret\n  selector:\n    matchLabels:\n      kind: build\n  sync: true\n</code></pre> <p>As we can see, in our TGI, we have a field <code>spec.sync</code> which is set to <code>true</code>. This will update the resources on two conditions:</p> <ul> <li>The Template CR is updated</li> <li> <p>The ClusterTemplateInstance CR is reconciled/updated</p> </li> <li> <p>If, for any reason, the underlying resource gets updated or deleted, <code>ClusterTemplateInstance</code> CR will try to revert it back to the state mentioned in the <code>Template</code> CR.</p> </li> </ul> <p>Note</p> <p>Updates to ServiceAccounts are ignored by both, reconciler and informers, in an attempt to avoid conflict between the TGI controller and Kube Controller Manager. ServiceAccounts are only reverted in case of unexpected deletions when sync is true.</p>"},{"location":"kubernetes-resources/how-to-guides/resource-sync-by-tgi.html#ignore-resources-updates-on-resources","title":"Ignore Resources Updates on Resources","text":"<p>If the resources mentioned in <code>Template</code> CR conflict with another controller/operator, and you want ClusterTemplateInstance to not actively revert the resource updates, you can add the following label to the conflicting resource <code>multi-tenant-operator/ignore-resource-updates: \"\"</code>.</p> <pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: docker-secret\nresources:\n  manifests:\n\n    - kind: Secret\n      apiVersion: v1\n      metadata:\n        name: docker-pull-secret\n      data:\n        .dockercfg: eyAKICAiaHR0cHM6IC8vaW5kZXguZG9ja2VyLmlvL3YxLyI6IHsgImF1dGgiOiAiYzNSaGEyRjBaWEk2VjI5M1YyaGhkRUZIY21WaGRGQmhjM04zYjNKayJ9Cn0K\n      type: kubernetes.io/dockercfg\n\n    - apiVersion: v1\n      kind: ServiceAccount\n      metadata:\n        name: example-automated-thing\n        labels:\n          multi-tenant-operator/ignore-resource-updates: \"\"\n      secrets:\n        - name: example-automated-thing-token-zyxwv\n</code></pre> <p>Note</p> <p>However, this label will not stop Multi Tenant Operator from updating the resource on following conditions: - Template gets updated - ClusterTemplateInstance gets updated - Resource gets deleted</p> <p>If you don't want to sync the resources in any case, you can disable sync via <code>sync: false</code> in <code>ClusterTemplateInstance</code> spec.</p>"},{"location":"kubernetes-resources/how-to-guides/template-default-params.html","title":"Using Templates with Default Parameters","text":""},{"location":"kubernetes-resources/how-to-guides/template-default-params.html#using-templates-with-default-parameters","title":"Using Templates with Default Parameters","text":"<pre><code>apiVersion: templates.stakater.com/v1alpha1\nkind: Template\nmetadata:\n  name: namespace-parameterized-restrictions\nparameters:\n  # Name of the parameter\n  - name: DEFAULT_CPU_LIMIT\n    # The default value of the parameter\n    value: \"1\"\n  - name: DEFAULT_CPU_REQUESTS\n    value: \"0.5\"\n    # If a parameter is required the template instance will need to set it\n    # required: true\n    # Make sure only values are entered for this parameter\n    validation: \"^[0-9]*\\\\.?[0-9]+$\"\nresources:\n  manifests:\n    - apiVersion: v1\n      kind: LimitRange\n      metadata:\n        name: namespace-limit-range-${namespace}\n      spec:\n        limits:\n          - default:\n              cpu: \"${{DEFAULT_CPU_LIMIT}}\"\n            defaultRequest:\n              cpu: \"${{DEFAULT_CPU_REQUESTS}}\"\n            type: Container\n</code></pre> <p>Parameters can be used with both <code>manifests</code> and <code>helm charts</code></p>"}]}